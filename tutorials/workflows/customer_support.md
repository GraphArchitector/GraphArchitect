# Workflow: Обработка запросов поддержки

**Сценарий**: Автоматическая обработка запросов клиентов  
**Сложность**: Средняя  
**Время**: 30 минут

---

## Описание задачи

Клиенты присылают запросы в службу поддержки. Нужно:
1. Классифицировать запрос (вопрос/жалоба/предложение)
2. Сгенерировать подходящий ответ
3. Проверить качество ответа
4. Отправить клиенту

---

## Архитектура Workflow

### Граф задачи

```
Запрос клиента
    ↓
┌─────────────────────────────────┐
│ Шаг 1: Классификация            │
│ - Определить тип запроса        │
│ - Определить приоритет          │
│ - Извлечь ключевые темы         │
└────────────┬────────────────────┘
             ↓
┌─────────────────────────────────┐
│ Шаг 2: Генерация ответа         │
│ - Выбрать тон (формальный/друж.)│
│ - Сгенерировать текст ответа    │
│ - Добавить релевантную информ.  │
└────────────┬────────────────────┘
             ↓
┌─────────────────────────────────┐
│ Шаг 3: Контроль качества        │
│ - Проверить корректность        │
│ - Проверить тон                 │
│ - Проверить полноту             │
└────────────┬────────────────────┘
             ↓
Готовый ответ клиенту
```

---

## Реализация

### Шаг 1: Запуск сервера

```bash
cd .\src\GraphArchitectLib\Web
python main.py
```

### Шаг 2: Отправка запроса

**Примеры запросов клиентов**:

```python
import requests
import json

def send_support_request(message):
    """Отправить запрос в поддержку"""
    response = requests.post(
        "http://localhost:8000/api/chat/support/message/stream",
        data={
            "message": message,
            "planning_algorithm": "yen_5"
        },
        stream=True
    )
    
    print(f"\nЗапрос: {message}")
    print("-" * 70)
    
    for line in response.iter_lines():
        if line:
            chunk = json.loads(line)
            
            if chunk['type'] == 'agent_selected':
                print(f"  Шаг: {chunk.get('step_id', 'unknown')}")
                print(f"  Выбран: {chunk['agent_id']}")
                print(f"  Вероятность: {chunk['score']:.3f}")
                print()
            
            elif chunk['type'] == 'text':
                print(f"  Результат: {chunk['content']}")


# Тест 1: Жалоба
send_support_request(
    "Я жду доставку уже неделю! Где мой заказ? Хочу возврат денег!"
)

# Тест 2: Вопрос
send_support_request(
    "Как мне изменить адрес доставки для заказа #12345?"
)

# Тест 3: Предложение
send_support_request(
    "Было бы здорово добавить оплату криптовалютой"
)
```

---

## Ожидаемый вывод

### Для жалобы

```
Запрос: Я жду доставку уже неделю! Где мой заказ?
----------------------------------------------------------------------

  Шаг: step-1-classification
  Выбран: agent-classifier-gpt4
  Вероятность: 0.723

  Шаг: step-2-response
  Выбран: agent-responder-formal
  Вероятность: 0.654

  Шаг: step-3-qa
  Выбран: agent-qa-strict
  Вероятность: 0.891

  Результат: [Formal Responder] Уважаемый клиент, приносим извинения 
  за задержку. Мы проверим статус вашего заказа и свяжемся с вами в 
  течение 24 часов...
```

### Для вопроса

```
Запрос: Как мне изменить адрес доставки?
----------------------------------------------------------------------

  Шаг: step-1-classification
  Выбран: agent-classifier-fast
  Вероятность: 0.567

  Шаг: step-2-response
  Выбран: agent-responder-friendly
  Вероятность: 0.712

  Шаг: step-3-qa
  Выбран: agent-qa-balanced
  Вероятность: 0.634

  Результат: [Friendly Responder] Конечно! Чтобы изменить адрес доставки,
  перейдите в раздел "Мои заказы", выберите нужный заказ...
```

---

## Анализ выбора инструментов

### Почему GPT-4 для жалобы?

```
Логит GPT-4: cos_sim(задача, GPT-4) + log(0.98) = 0.87 + (-0.02) = 0.85
Логит Claude: cos_sim(задача, Claude) + log(0.95) = 0.76 + (-0.05) = 0.71
Логит Local: cos_sim(задача, Local) + log(0.78) = 0.45 + (-0.25) = 0.20

Температура: (1.0/3) * Σ√(variance / sample_size) = 0.312

Softmax:
  P(GPT-4) = exp(0.85/0.312) / Z = 0.723
  P(Claude) = exp(0.71/0.312) / Z = 0.254
  P(Local) = exp(0.20/0.312) / Z = 0.023
```

GPT-4 имеет:
- Высокую репутацию (0.98)
- Высокое сходство с задачей
- Следовательно, высокую вероятность выбора

### Почему Friendly Responder для вопроса?

Вопросы требуют дружелюбного, а не формального тона.

---

## Кастомизация Workflow

### Изменение алгоритма планирования

```bash
# Dijkstra - быстрый, один путь
planning_algorithm=dijkstra

# Yen топ-3 - три альтернативы
planning_algorithm=yen_3

# Ant Colony - вероятностный
planning_algorithm=ant_5
```

### Добавление контекста

```python
# С документами
response = requests.post(
    "http://localhost:8000/api/chat/support/document",
    files={"file": open("faq.pdf", "rb")}
)

# Затем с контекстом
response = requests.post(
    "http://localhost:8000/api/chat/support/message/stream",
    data={
        "message": "Вопрос о доставке",
        "planning_algorithm": "yen_5"
    }
)
```

---

## Мониторинг качества

### Проверка статистики

```bash
curl http://localhost:8000/api/training/statistics
```

Результат:
```json
{
  "enabled": true,
  "total_executions": 15,
  "average_quality": 0.873,
  "success_rate": 0.933,
  "average_execution_time": 4.32,
  "average_cost": 0.065
}
```

### Метрики инструментов

```bash
curl http://localhost:8000/api/training/tools
```

Результат: Топ инструменты по репутации после обучения.

---

## Оптимизация Workflow

### Балансировка скорость/качество

**Быстрый workflow** (для простых запросов):
```
[Fast Classifier] → [Friendly Responder] → [Fast QA]
```
- Время: ~2s
- Стоимость: $0.01
- Качество: 75%

**Качественный workflow** (для жалоб):
```
[GPT-4 Classifier] → [Formal Responder] → [Strict QA]
```
- Время: ~8s
- Стоимость: $0.08
- Качество: 95%

### Автоматический выбор

GraphArchitect может выбирать автоматически на основе:
- Тона запроса (жалоба → качественный путь)
- Приоритета (VIP клиент → лучшие инструменты)
- Бюджета (лимит стоимости)

---

## Интеграция с CRM

### Сохранение в БД

```python
# После выполнения сохранить в вашу систему
result = execute_support_workflow(request)

# Сохранить в CRM
save_to_crm({
    "customer_id": customer_id,
    "request": request,
    "category": result['category'],
    "response": result['response'],
    "quality_score": result['quality'],
    "processing_time": result['time']
})
```

### Автоматическая отправка

```python
if result['quality_score'] > 0.9:
    # Высокое качество - отправить автоматически
    send_email_to_customer(response)
else:
    # Требуется ревью человеком
    add_to_review_queue(response)
```

---

## Метрики успешности

### KPI для Customer Support Workflow

| Метрика | Цель | Текущее |
|---------|------|---------|
| Точность классификации | > 90% | 87% |
| Качество ответа | > 85% | 91% |
| Время обработки | < 10s | 4.3s |
| Стоимость на запрос | < $0.10 | $0.065 |
| Удовлетворенность | > 80% | 92% |

### Как улучшить

1. **Точность классификации**: Добавить примеры в NLI датасет
2. **Качество ответа**: Использовать GPT-4 вместо GPT-3.5
3. **Время**: Использовать кеширование
4. **Стоимость**: Использовать локальные модели где возможно

---

## Расширенные сценарии

### Мультиязычная поддержка

```python
# Определение языка
[Language Detector] → ...

# Перевод если нужно
if detected_language != "ru":
    [Translator] → [Classifier] → [Responder] → [Translator] → [QA]
else:
    [Classifier] → [Responder] → [QA]
```

### Эскалация сложных случаев

```python
if complexity_score > 0.8 or sentiment == "very_negative":
    # Эскалация человеку
    add_to_human_queue()
else:
    # Автоматическая обработка
    execute_workflow()
```

---

## Итоги

### Вы создали

- Полноценный workflow для customer support
- 3-шаговый процесс обработки
- Автоматический выбор инструментов
- Систему контроля качества

### Вы узнали

- Как структурировать многошаговую задачу
- Как выбирать инструменты для каждого шага
- Как мониторить качество
- Как оптимизировать под KPI

### Применение

Этот workflow можно использовать для:
- Email поддержки
- Чат-ботов
- Тикет-систем
- FAQ генерации

---

**Следующий workflow**: [Создание контента](content_creation.md)
