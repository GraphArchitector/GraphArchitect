# Туториал 2: Основные концепции

**Уровень**: Начинающий  
**Время**: 15 минут  
**Цель**: Понять ключевые концепции GraphArchitect

---

## Что вы узнаете

- Что такое граф инструментов
- Как работают коннекторы
- Что такое стратегия выполнения
- Как происходит выбор инструментов
- Как работает обучение

---

## Концепция 1: Граф инструментов

### Что это?

**Граф инструментов** - это структура данных где:
- **Вершины** = форматы данных (коннекторы)
- **Ребра** = инструменты, которые преобразуют один формат в другой

### Пример

```
Задача: "Классифицировать текст"

Граф:
  text|question ──[Classifier]──> text|category
  text|question ──[QA System]───> text|answer
  text|outline ──[Writer]───────> text|content
```

### Почему граф?

- **Гибкость**: Множество путей для одной задачи
- **Оптимизация**: Выбор кратчайшего/лучшего пути

---

## Концепция 2: Коннекторы

### Что это?

**Коннектор** - формат данных в виде `data_format|semantic_format`

### Примеры

```
text|question    - Текстовый вопрос
text|answer      - Текстовый ответ
text|category    - Текстовая категория
text|content     - Полный контент
image|raw        - Сырое изображение
text|code        - Исходный код
```

### Как используются?

```python
# Инструмент определяет что он принимает и возвращает
class Classifier(BaseTool):
    input = Connector("text", "question")   # Принимает вопросы
    output = Connector("text", "category")  # Возвращает категории
```

### Зачем нужны?

- **Типизация**: Система знает какие данные где
- **Совместимость**: Проверка сочетаемости инструментов
- **Планирование**: Поиск пути от входного к выходному формату

---

## Концепция 3: Стратегия выполнения

### Что это?

**Стратегия** - последовательность инструментов для решения задачи.

### Пример

```
Задача: Создать качественную статью

Стратегия 1 (простая):
  [Outliner] → [Writer]

Стратегия 2 (качественная):
  [Outliner] → [Writer] → [Style Checker] → [QA]

Стратегия 3 (альтернативная):
  [Researcher] → [Outliner] → [Technical Writer] → [QA]
```

### Как выбирается?

GraphArchitect использует алгоритмы поиска:

- **Dijkstra**: Один кратчайший путь
- **A***: С эвристикой (быстрее)
- **Yen**: Топ-K лучших путей
- **ACO**: Вероятностный поиск (муравьиный алгоритм)

---

## Концепция 4: Выбор инструмента

### Проблема

На каждом шаге может быть несколько кандидатов:

```
Шаг: Classification
Кандидаты:
  - GPT-4 Classifier (дорогой, точный)
  - Claude Classifier (средний)
  - Local Classifier (быстрый, дешевый)
```

Как выбрать?

### Решение: Softmax с температурой

```
1. Вычислить логиты для каждого:
   logit = cosine_similarity(задача, инструмент) + log(reputation)
cosine_similarity — косинусное_сходство, мера похожести двух векторов
log(reputation) - логарифм репутации

2. Вычислить температуру группы:
   T = (C/K) * Σ√(variance / sample_size)
variance - дисперсия
sample_size — количество выборки
C — масштабирующая константа.
K — число инструментов.

3. Применить softmax:
   P(инструмент) = exp(logit / T) / Σ exp(logit_i / T)

4. Сэмплировать:
   Выбрать инструмент вероятностно
```

### Почему вероятностно?

- **Вариативность**: Cнижает риск "застрять" на инструменте
- **Обучение**: Собираем данные о разных инструментах
- **Адаптивность**: Температура снижается по мере обучения

---

## Концепция 5: Обучение (Policy Gradient)

### Как работает?

После каждого выполнения:

```
1. Оценка качества (автоматическая или пользовательская)
   quality_score = 0.87

2. Вычисление advantage:
   advantage = quality_score - baseline (текущая репутация)

3. Обновление репутации:
   new_reputation = old_reputation + learning_rate * advantage

4. Обновление эмбеддингов (Contrastive Learning):
   embedding += learning_rate * (task_emb - tool_emb) * quality
```

### Результат

После 100 выполнений:
- Репутация хороших инструментов растет
- Плохие инструменты используются реже
- Температура снижается (больше уверенности)
- Система тщательнее выбирает инструменты

---

## Концепция 6: Natural Language Interface (NLI)

### Что это?

**NLI** - компонент, который преобразует естественный язык в коннекторы.

### Пример

```
Вход: "Классифицировать этот текст"
  ↓ NLI
Коннекторы: text|question → text|category
```

### Как работает?

1. **k-NN поиск**: Находит похожие примеры из датасета
2. **Предсказание**: Использует коннекторы из лучшего совпадения
3. **Использование**: Передает коннекторы в GraphStrategyFinder

### Зачем?

Пользователь пишет на естественном языке, система автоматически понимает что нужно сделать.

---

## Полный цикл выполнения

### Шаги обработки запроса

```
Запрос пользователя
    ↓
[1. NLI Parsing]
    Естественный язык → Коннекторы
    ↓
[2. Strategy Finding]
    Поиск путей в графе (Dijkstra/Yen/ACO)
    ↓
[3. Tool Selection]
    Softmax выбор для каждого шага
    ↓
[4. Execution]
    Выполнение цепочки инструментов
    ↓
[5. Training]
    Обучение на основе результата
    ↓
Результат пользователю
```

### Время выполнения

- NLI: < 0.01s
- Поиск стратегий: 0.01-0.1s
- Выбор инструментов: < 0.01s на шаг
- Выполнение: зависит от инструментов
- Обучение: < 0.01s

**Общее**: 2-10 секунд (в основном выполнение)

---

## Практическое упражнение

### Задание 1: Отправьте 3 запроса

```
1. "Классифицировать отзыв клиента"
```

```
2. "Создать статью о машинном обучении"
```

```
3. "Проверить качество этого документа"
```

### Задание 2: Наблюдайте

Для каждого запроса обратите внимание:
- Какие инструменты были кандидатами?
- Какой был выбран?
- Какая была вероятность (из softmax)?
- Сколько времени заняло?

### Задание 3: Проверьте логи

В терминале где запущен сервер вы увидите:

```
INFO - Executing task: Классифицировать...
INFO - Found 2 strategies
INFO - Selected: GPT-4 Classifier
INFO - Task completed: COMPLETED
```

---

## Ключевые термины

| Термин | Определение |
|--------|-------------|
| **Инструмент (Tool)** | Компонент, выполняющий одну задачу |
| **Агент (Agent)** | То же что Tool в контексте Web API |
| **Коннектор** | Формат данных (data\|semantic) |
| **Стратегия** | Последовательность инструментов |
| **Граф** | Структура связей между коннекторами через инструменты |
| **NLI** | Natural Language Interface для парсинга текста |
| **Softmax** | Вероятностный метод выбора инструментов |
| **Policy Gradient** | Метод обучения через обратную связь |

---

## Что происходит "под капотом"

### При отправке запроса "Классифицировать текст"

```
1. HTTP POST /api/chat/{id}/message/stream
   ↓
2. ChatService.process_full_workflow_stream()
   ↓
3. GraphArchitectBridge.execute_task_streaming()
   ↓
4. NLI.parse_task("Классифицировать текст", tools)
   → Коннекторы: text|question → text|category
   ↓
5. GraphStrategyFinder.find_strategies(tools, "text|question", "text|category", Yen, k=5)
   → Найдено 3 стратегии: [[Classifier-A], [Classifier-B], [Classifier-C]]
   ↓
6. ExecutionOrchestrator.execute_task(task, tools)
   → Для шага выбирается инструмент через softmax
   ↓
7. InstrumentSelector.select_instrument(classifiers, task_embedding, top_k=3)
   → Логиты → Температура → Softmax → Выбор: GPT-4 (p=0.65)
   ↓
8. BaseTool.execute(input_data)
   → [GPT-4 Classifier] Processed: ...
   ↓
9. TrainingOrchestrator.update_tool(tool, feedback)
   → Репутация обновлена: 0.95 → 0.953
   ↓
10. Результат пользователю
```

---

## Итоги

### Вы узнали

- GraphArchitect использует граф для планирования
- Коннекторы описывают форматы данных
- Стратегии - это пути в графе
- Выбор инструментов через softmax вероятностный
- Система обучается после каждого выполнения
- NLI позволяет использовать естественный язык

### Ключевые моменты

- **Автоматизация**: Система сама находит путь решения
- **Адаптивность**: Обучается на каждом выполнении
- **Гибкость**: Множество стратегий для одной задачи
- **Интеллектуальность**: Не random, а математически обоснованный выбор

---

**Время выполнения**: 15 минут  
**Следующий туториал**: [Первый Workflow](03_first_workflow.md)
